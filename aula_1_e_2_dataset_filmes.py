# -*- coding: utf-8 -*-
"""Aula 1 e 2 - Dataset - Filmes

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WUnRtOR93UCGZ196NNLDqwrHmkwlrTue
"""

##importação da lib pandas

import pandas as pd

filmes = pd.read_csv("https://raw.githubusercontent.com/alura-cursos/introducao-a-data-science/master/aula0/ml-latest-small/movies.csv")

##filmes é um dataframe (um tipo de tabela)

filmes.columns = ["filmeId", "título", "gêneros"] ##mudando os nomes das colunas
filmes.head()  ##mostra apenas as 5 primeiras linhas, pode ser alterado head(15), por exemplo

"""## Tópicos importantes da aula passada:

Tuplas, dic, matplotlip, pandas

Consultando os docstrings no notebook:
"""

?filmes.head # lendo a documentação de um método/atributo

?filmes # lendo a documentação do tipo (docstring)

"""##Baixando os dados das avaliações dos filmes (outro banco de dados)"""

avaliacoes = pd.read_csv("https://github.com/alura-cursos/introducao-a-data-science/blob/master/aula0/ml-latest-small/ratings.csv?raw=true")
avaliacoes.columns = ["usuarioId", "filmeId", "nota", "momento"]
avaliacoes.head()

"""Para saber a quantidade de linhas e de colunas, usa um comando para retornar uma [tupla](https://www.alura.com.br/artigos/conhecendo-as-tuplas-no-python). O primeiro termo indica o número de linhas e o segundo o número de colunas:"""

avaliacoes.shape

"""Podemos também usar o comando length, usado nas listas, mas devolve só a quantidade de linhas:"""

len(avaliacoes)

"""## Método para separar alguma coluna da tabela

Uma forma para "separar" as informações apenas do filmeId 1 é chamando o método` avaliacaoes.query("filmeId==1")`, esse método retornará apenas as linhas para quais a expressão booleana, `"filmeId==1"`, for `verdadeira`.

Tendo as informações do filmeId 1 podemos chamar o `avaliacoes_do_filme_1.describe(`), para analisar as estatítiscas gerais dos dados.
"""

avaliacoes_filme1 = avaliacoes.query("filmeId==1")  ##estou separando as informações do filme 1
avaliacoes_filme1.head(15)

"""Existe um comando para mostras os dados da tabela, o describe:"""

avaliacoes_filme1.describe()  ##vários dados não servem pra análise, como por exemplo a média do filmeId

"""Para usar de maneira mais específica, é possível puxar apenas um dos dados da tabela:"""

avaliacoes_filme1.mean()

"""Usando o describe na tabela das avaliações:"""

avaliacoes.describe()

avaliacoes_filme1.describe() ##apenas do filme 1

"""Agora preciso puxar só a média da nota. Pra isso eu uso o método de chave : valor."""

avaliacoes["nota"]   ##quero apenas a coluna de "nota" da tabela
avaliacoes.head()

avaliacoes_filme1["nota"].mean()  ## método pra mostrar a média das notas do filme 1

"""Nós calculamos uma média geral, uma média para o `"filmeId==1"`. Agora eu quero calcular a média das notas para todos os filmes, podemos fazer isso usando o método `.groupby(filmeId)`, o parâmetro passado é para indicar qual coluna ele deve utilizar para "agrupar" os dados. Depois só calcular a média como fizemos anteriormente."""

media_geral = avaliacoes.groupby("filmeId")["nota"].mean()    ##estou agrupando o filmeId com a média das notas
media_geral.round(2).head() #arredondado

"""Temos as notas médias calculadas, mas agora precisamos juntar as informações de notas médias com a base de dados filmes.

Poderíamos criar uma nova coluna e atribuir a váriável notas_medias_por_filme, de forma direta:

`filmes["nota_media"] = notas_medias_por_filme`

Como discutimos em aula, essa não é uma boa prática pois precisamos garantir que a nota média seja do respectivo filme.

Para garantir essa condição vamos utilizar o `.join()`, criando um novo dataframe `(filmes_com_media = filmes.join(notas_medias_por_filme, on="filmeId")).`

Veja como fazer, nas células a seguir:
"""

filmes

media_geral

filmes_com_media = filmes.join(media_geral, on="filmeId")  ##a coluna nota foi adicionada de acordo com o filmeId
filmes_com_media.round(2).head()

"""A tabela está desornada. É possível ordená-la de maneira crescente usando o `sort_values()`:"""

filmes_com_media.sort_values("nota", ascending=False).head(15)  ##vou ordenar de acordo com a nota

"""## Plotando os dados em gráficos

É possível transformar esses dados em gráficos usando o método `.plot `e o `matplotlib`, que dá pra manipular mais.
"""

avaliacoes.query("filmeId==1")["nota"].plot()  ##plotando as notas do filme 1

"""O gráfico ficou ruim pra esse tipo de análise, por isso usa o parâmetro `.kind`"""

avaliacoes.query("filmeId==1")["nota"].plot(kind='hist')  ##mudando o tipo de gráfico para histograma

"""Colocando o Título:"""

avaliacoes.query("filmeId==1")["nota"].plot(kind='hist', title="Avaliações do filme Toy Story")

"""## Usando o matplotlib

Trata-se de uma biblioteca que permite manipular gráficos. 

[matplotlib](https://matplotlib.org/)
"""

import matplotlib.pyplot as plt

avaliacoes.query("filmeId==1")["nota"].plot(kind='hist')
plt.title("Avaliações do filme: Toy Story")
plt.show()

"""## Desafio 1 do [Paulo Silveira](https://twitter.com/paulo_caelum)

O Paulo fez uma análise rápida e disse que tem 18 filmes sem avaliações, será que ele acertou?

Determine quantos filmes não tem avaliações e quais são esses filmes.
"""

filmes_com_media.query("nota == 'NaN'") ##comparando a nota de maneira literal com o string 'NaN'

"""RESPOSTA DOS PROFESSORES:

selecao = filmes_com_media['nota'].isnull()


filmes_com_media[selecao]

```
# This is formatted as code
```
"""

filmes_com_media.query("nota == 'NaN'").shape ##pra mostrar o quanto de linhas e colunas tem

"""## Desafio 2 do [Guilherme Silveira](https://twitter.com/guilhermecaelum)

Mudar o nome da coluna nota do dataframe **filmes_com_media** para nota_média após o join.
"""

filmes_com_media.columns = ["filmeId", "título", "gêneros", "nota_média"]

filmes_com_media.head()

"""RESPOSTA DOS PROFESSORES: 

filmes_com_media = filmes_com_media.rename(columns={'nota': 'nota_media'})


filmes_com_media.head()

```
# This is formatted as code
```

## Desafio 3 do [Guilherme Silveira](https://twitter.com/guilhermecaelum)

Colocar o número de avaliações por filme, isto é, não só a média mas o TOTAL de votos por filme.
"""

contagem_geral = avaliacoes.groupby("filmeId")["nota"].count() 
contagem_geral.head()

##tabela de contagem de acordo com o filmeId

"""RESPOSTA DOS PROFESSORES:

total_votos_por_filme = avaliacoes.groupby('filmeId')['nota'].count()


total_votos_por_filme.head()
"""

filmes_com_contagem = filmes_com_media.join(contagem_geral, on="filmeId")
filmes_com_contagem.columns = ["filmeId", "título", "gêneros", "nota_média", "total"]
filmes_com_contagem.sort_values("total", ascending=False).head(15)  ##vou ordenar de acordo com a contagem

"""## Desafio 4 do [Thiago Gonçalves](https://twitter.com/tgcsantos)

Arredondar as médias (coluna de nota média) para duas casas decimais.
"""

media_geral.round(2)

filmes_com_contagem.round(2).head(15)

"""RESPOSTA DOS PROFESSORES:

filmes_com_media_e_votos['nota_media'] = filmes_com_media_e_votos['nota_media'].round(2)


filmes_com_media_e_votos

## Desafio 5 do [Allan Spadini](https://twitter.com/allanspadini)

Descobrir os generos dos filmes (quais são eles, únicos). (esse aqui o bicho pega)

*Copiei de um exercício resolvido, pois desconhecia as funções. A lógica na minha cabeça ta no caminho certo*
"""

##generos = filmes["gêneros"].str.split("|", expand=False) o false cria listas do que foi separado, se for true, cria colunas separadas
generos = filmes["gêneros"].str.split("|", expand=True).stack().to_frame("gêneros")
##o stack empilha e o to_frame organiza em uma coluna de gêneros.
generos.stack().unique() ##agrupado por unicidade

generos

len(generos.stack().unique())-1 ##quantidade de gêneros retirando o não listado

"""RESPOSTA DOS PROFESSORES:

generos_df = filmes_com_media_e_votos.generos.str.get_dummies('|') ##get_dummies é para separar as strings

generos = generos_df.columns.to_list()

generos


PARTE POR PARTE (EXPLICAÇÃO DO GET DUMMIES):
"""

filmes_com_contagem["gêneros"].str.get_dummies('|') #onde tem 1 é true, 0 false. Na primeira linha tem um filme de aventura, animação, para criança, comédia etc

filmes_com_contagem["gêneros"].str.get_dummies('|').sum().sort_values(ascending=False) ##por padrão soma por coluna, se quisesse por linha colocava o parâmetro: axis=1

"""# ESSA É UMA SÉRIE DE VALORES PORQUE SÓ TEM UMA COLUNA. SE TIVER MAIS DE UMA COLUNA É UM DATAFRAME, COMO O FILMES

os nomes dos gêneros são só os índices
"""

filmes_com_contagem["gêneros"].str.get_dummies('|').sum().sort_values(ascending=False).index

filmes_com_contagem["gêneros"].str.get_dummies('|').sum().sort_values(ascending=False).values

"""## Desafio 6 da [Thais André](https://twitter.com/thais_tandre)

Contar o número de aparições de cada genero.

*Copiei de um exercício resolvido, pois desconhecia as funções. A lógica na minha cabeça ta no caminho certo*
"""

total_generos = generos.melt().groupby("value").count().sort_values("variable", ascending=False)
total_generos

##RESPOSTA DOS PROFESSORES:

##total_filmes_por_genero = filmes_com_media_e_votos.generos.str.get_dummies().sum()  ##O STR É PRA USAR FUNÇÕES DE STRINGS NO DATAFRAME

##total_filmes_por_genero

"""## Desafio 7 do [Guilherme Silveira](https://twitter.com/guilhermecaelum)

Plotar o gráfico de aparições de cada genero. Pode ser um gráfico de tipo igual a barra.
"""

import matplotlib.pyplot as plt

total_generos.plot.bar()
plt.title("Gráfico da contagem de gêneros")
plt.show()

"""## AULA 2

## ESTUDANDO A MÉDIA E A MEDIANA

##Desafio 1 do [Guilherme Silveira](https://twitter.com/guilhermecaelum)

Rotacionar os thicks (os nomes dos generos) do gráfico de barras verdes (o último), de forma a deixar as legendas mais legíveis.
"""

import seaborn as sns  ##vou trabalhar com paletes de cor
import matplotlib.pyplot as plt
sns.set_style("whitegrid")

total_generos = filmes_com_contagem["gêneros"].str.get_dummies('|').sum().sort_values(ascending=False)
plt.figure(figsize=(16,8)) ##o primeiro parâmetro é do eixo x e o segundo do y
sns.barplot(
      x= total_generos.index,
      y= total_generos.values, ##escolhendo o que vai ser no eixo x e no eixo y
      palette=sns.color_palette("BuGn_r", n_colors=len(total_generos) + 4)
)

degrees = 45
plt.xticks(rotation=degrees)

plt.show()

import matplotlib.pyplot as plt

def plot_filme(n):
  notas_do_filme = avaliacoes.query(f"filmeId=={n}")["nota"]
  print()
  notas_do_filme.plot(kind='hist')
  plt.show()
  notas_do_filme.plot.box()
  plt.show()
  return notas_do_filme.describe()

plot_filme(46578)

"""## Desafio 2 do [Paulo Silveira](https://twitter.com/paulo_caelum)

Encontar vários filmes com médias próximas e distribuições diferentes, use a função **plot_filmes(n)** para plotar.
"""

filmes_com_media.sort_values("nota_média", ascending=False)[3400:4000]

import matplotlib.pyplot as plt
import seaborn as sns

plt.title("Média do filme: Treasure of the Sierra Madre, The (1948)")
plot_filme(1254)

print()

plt.title("Time to Kill, A (1996)")
plot_filme(805)

print()


plt.title("Strictly Ballroom (1992)")
plot_filme(1148)

print()

plt.title("The Intern (2015)")
plot_filme(140110)

"""## DESAFIO 3:

Criar o boxplot dos 10 filmes com mais votos (não é com maior média, é com mais votos!). Não apenas plot mas também analise e tente tirar conclusões.
"""

filmes_com_contagem.sort_values("total", ascending=False).head(10) ##dataframe com a contagem dos filmes

import matplotlib.pyplot as plt

maior_qntd_votos = filmes_com_contagem.sort_values("total", ascending=False).head(10) #variável de uma tabela com os mais votados
plt.title("Bloxplot da média dos 10 mais votados")
sns.boxplot(data = avaliacoes.query("filmeId in [356,318, 296, 593, 2571, 260, 480, 110, 589, 527]"), x ="filmeId", y="nota")
plt.show()

"""## Desafio 4 do [Guilherme Silveira](https://twitter.com/guilhermecaelum)

Configurar a visualização do boxplot gerado pelo seaborn (último boxplot plotado na aula). Configurar o tamanho e colocar o nome dos filmes nos thicks.
"""

import matplotlib.pyplot as plt



maior_qntd_votos = filmes_com_contagem.sort_values("total", ascending=False).head(10) #variável de uma tabela com os mais votados
plt.figure(figsize=(18,6))
plt.title("Bloxplot da média dos 10 mais votados")
grafico1 = sns.boxplot(data = avaliacoes.query("filmeId in [356,318, 296, 593, 2571, 260, 480, 110, 589, 527]"), x ="filmeId", y="nota")
grafico1.set_xticklabels(filmes.query("filmeId in [356,318,296,593,2571,260,480,110,589,527]")['título'], fontsize=10)
grafico1.set_xlabel("Filme", fontsize=16)
grafico1.set_ylabel("Nota", fontsize=16)  ##mudar o nome dos eixos
degrees = 45
plt.xticks(rotation=degrees) #rotação das ticks
plt.show()

"""## Desafio 5 do [Allan Spadini](https://twitter.com/allanspadini)

Calcular moda, média e mediana dos filmes. Explore filmes com notas mais próximas de 0.5, 3 e 5.
"""

loca_filmes = filmes_com_contagem.query("filmeId==172591") #Localizando os filmes
loca_filmes
#Filmes escolhidos para o exercício:
#filme 59306 - a
#filme 3649 - b
#filme 172591 - c

#DADOS FILME 59306 - a

def estatisticas(filme_id):
    notas = avaliacoes.query(f"filmeId=={filme_id}")["nota"]
    titulo = filmes.query(f"filmeId=={filme_id}")["título"]
    media = notas.mean()
    mediana = notas.median()
    moda = notas.mode().values
    print ("Filme: ", titulo.iloc[0], "\n Média: ", media, "\n Mediana: ", mediana, "\n Moda: ", moda)

estatisticas(59306)
print()
estatisticas(3649)
print()
estatisticas(172591)

"""## Desafio 6 da [Thais André](https://twitter.com/thais_tandre)

Plotar o boxplot e o histograma um do lado do outro (na mesma figura ou em figuras distintas, mas um do lado do outro).
"""

import seaborn as sns
import matplotlib.pyplot as plt

fight_club = avaliacoes.query("filmeId==2959")['nota']

f, axes = plt.subplots(1, 2, figsize=(18, 6))


grafico2 = fight_club.plot(kind='hist', ax=axes[0])
grafico2.set_xlabel("Notas", fontsize=14)
grafico2.set_ylabel("Frequências", fontsize=14)



filmes_com_contagem.sort_values("total", ascending=False).head(20) #organizei para escolher um filme que teve muitos votos: filmeId=2959
plt.title("Fight Club (1999)", fontsize=16)
grafico1 = sns.boxplot(data=avaliacoes.query("filmeId in[2959]"),x="filmeId", y="nota").ax=axes[1] #escolho o dataframe de avaliações porque eu preciso de toda a variação, o dataframe filmes_com_cotagem só tem o valor médio
grafico1.set_xlabel("Filme", fontsize=14)
grafico1.set_ylabel("Nota", fontsize=14)
grafico1.set_xticklabels(filmes.query("filmeId in[2959]")["título"],fontsize=10)
plt.show()

"""## Desafio 7 do [Thiago Gonçalves](https://twitter.com/tgcsantos)

Criar um gráfico de notas médias por ano (média geral considerando todos os filmes lançados naquele ano).
"""

filmes_com_media_e_ano = filmes_com_media.copy()
filmes_com_media_e_ano['ano'] = filmes_com_media['título'].str.extract("\((\d{4})\)")  #criando uma series em que eu vou extrair componentes de uma coluna: título
del filmes_com_media_e_ano['data'] #estava duplicado
filmes_com_media_e_ano            
#explicando o codigo acima: o primeiro parentese é da expressão. Depois vem \ que indica que vou usar um caracter especial para imprimir, que são os parenteses da data. Aí tem outra expressão (\d{4}), que significa que faz referências a numeros de 0-9, 4 numeros no caso.

#tenho agora uma series só com datas

import matplotlib.pyplot as plt

plt.figure(figsize=(18, 8))
media_por_ano = filmes_com_media_e_ano.groupby("ano")["nota_média"].mean().round(2)
plt.title("Avaliações médias por ano") 
media_por_ano.plot()
plt.show()